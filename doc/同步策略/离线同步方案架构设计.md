# ç¦»çº¿ä¼˜å…ˆè®°è´¦åº”ç”¨åŒæ­¥æ¶æ„è®¾è®¡

## ğŸ¯ æ ¸å¿ƒè®¾è®¡åŸåˆ™

### 1. ç¦»çº¿ä¼˜å…ˆç­–ç•¥
- **æœ¬åœ°æ•°æ®ä¸ºä¸»**ï¼šæ‰€æœ‰åŠŸèƒ½éƒ½èƒ½ç¦»çº¿å·¥ä½œ
- **å¢é‡åŒæ­¥**ï¼šåªåŒæ­¥å˜æ›´çš„æ•°æ®ï¼Œå‡å°‘ç½‘ç»œå¼€é”€
- **å†²çªè§£å†³**ï¼šæ™ºèƒ½å¤„ç†å¤šç”¨æˆ·åŒæ—¶ç¼–è¾‘çš„å†²çª
- **æœ€ç»ˆä¸€è‡´æ€§**ï¼šä¿è¯æ‰€æœ‰è®¾å¤‡æœ€ç»ˆæ•°æ®ä¸€è‡´

### 2. æ•°æ®åŒæ­¥æ¶æ„

```mermaid
graph TB
    A[ç”¨æˆ·è®¾å¤‡A] --> D[æœ¬åœ°SQLite]
    B[ç”¨æˆ·è®¾å¤‡B] --> E[æœ¬åœ°SQLite] 
    C[ç”¨æˆ·è®¾å¤‡C] --> F[æœ¬åœ°SQLite]
    
    D --> G[åŒæ­¥é˜Ÿåˆ—]
    E --> G
    F --> G
    
    G --> H[äº‘ç«¯æœåŠ¡å™¨]
    H --> I[MySQLä¸»åº“]
    H --> J[åŒæ­¥æ—¥å¿—è¡¨]
    
    H --> G
```

## ğŸ—ƒï¸ æ•°æ®åº“è®¾è®¡ï¼ˆæ”¯æŒç¦»çº¿åŒæ­¥ï¼‰

### 1. æœ¬åœ°SQLiteè¡¨ç»“æ„å¢å¼º

```sql
-- 1. ä¸ºæ‰€æœ‰è¡¨æ·»åŠ åŒæ­¥ç›¸å…³å­—æ®µ
ALTER TABLE records ADD COLUMN sync_status INTEGER DEFAULT 0;  -- 0:æœªåŒæ­¥ 1:å·²åŒæ­¥ 2:å†²çª
ALTER TABLE records ADD COLUMN local_version INTEGER DEFAULT 1;
ALTER TABLE records ADD COLUMN server_version INTEGER DEFAULT 0;
ALTER TABLE records ADD COLUMN last_sync_at TIMESTAMP;
ALTER TABLE records ADD COLUMN conflict_data TEXT; -- JSONæ ¼å¼å­˜å‚¨å†²çªæ•°æ®
ALTER TABLE records ADD COLUMN device_id TEXT; -- è®¾å¤‡å”¯ä¸€æ ‡è¯†

-- 2. åŒæ­¥é˜Ÿåˆ—è¡¨ï¼ˆæœ¬åœ°ï¼‰
CREATE TABLE sync_queue (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    table_name TEXT NOT NULL,           -- è¡¨å
    record_id TEXT NOT NULL,            -- è®°å½•IDï¼ˆUUIDï¼‰
    operation TEXT NOT NULL,            -- CREATE/UPDATE/DELETE
    data TEXT,                          -- JSONæ ¼å¼çš„æ•°æ®
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    retry_count INTEGER DEFAULT 0,
    status INTEGER DEFAULT 0            -- 0:å¾…åŒæ­¥ 1:åŒæ­¥ä¸­ 2:å·²åŒæ­¥ 3:å¤±è´¥
);

-- 3. è®¾å¤‡ä¿¡æ¯è¡¨
CREATE TABLE device_info (
    device_id TEXT PRIMARY KEY,
    device_name TEXT,
    last_sync_at TIMESTAMP,
    sync_token TEXT                     -- ç”¨äºå¢é‡åŒæ­¥çš„æ ‡è®°
);

-- 4. å†²çªè§£å†³è®°å½•è¡¨
CREATE TABLE conflict_resolution (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    table_name TEXT NOT NULL,
    record_id TEXT NOT NULL,
    conflict_type TEXT NOT NULL,        -- field_conflict/delete_conflict
    resolution_strategy TEXT,           -- local_wins/server_wins/merge/manual
    resolved_at TIMESTAMP,
    resolved_by TEXT                    -- è§£å†³å†²çªçš„ç”¨æˆ·
);
```

### 2. äº‘ç«¯æ•°æ®åº“è¡¨ç»“æ„å¢å¼º

```sql
-- 1. åŒæ­¥æ—¥å¿—è¡¨ï¼ˆç”¨äºå¢é‡åŒæ­¥ï¼‰
CREATE TABLE sync_logs (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    account_id INT NOT NULL,
    table_name VARCHAR(50) NOT NULL,
    record_id VARCHAR(50) NOT NULL,
    operation ENUM('CREATE', 'UPDATE', 'DELETE') NOT NULL,
    user_id INT NOT NULL,
    device_id VARCHAR(50) NOT NULL,
    data_before JSON,                   -- æ“ä½œå‰æ•°æ®
    data_after JSON,                    -- æ“ä½œåæ•°æ®
    version_number INT NOT NULL,        -- ç‰ˆæœ¬å·
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_account_version (account_id, id),
    INDEX idx_record (table_name, record_id)
);

-- 2. è®¾å¤‡æ³¨å†Œè¡¨
CREATE TABLE devices (
    device_id VARCHAR(50) PRIMARY KEY,
    user_id INT NOT NULL,
    device_name VARCHAR(100),
    device_type ENUM('ios', 'android', 'web') NOT NULL,
    last_sync_at TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 3. åŒæ­¥é”è¡¨ï¼ˆé˜²æ­¢å¹¶å‘åŒæ­¥å†²çªï¼‰
CREATE TABLE sync_locks (
    account_id INT PRIMARY KEY,
    locked_by_device VARCHAR(50),
    locked_at TIMESTAMP,
    expires_at TIMESTAMP
);
```

## ğŸ”„ åŒæ­¥æœºåˆ¶è®¾è®¡

### 1. æ•°æ®æ“ä½œæµç¨‹

```python
# app/services/offline_service.py
import uuid
import sqlite3
import json
from datetime import datetime
from typing import Dict, List, Any, Optional

class OfflineDataService:
    def __init__(self, db_path: str):
        self.db_path = db_path
        self.device_id = self._get_or_create_device_id()
    
    def create_record(self, table_name: str, data: Dict[str, Any]) -> str:
        """åˆ›å»ºè®°å½•ï¼ˆç¦»çº¿ä¼˜å…ˆï¼‰"""
        record_id = str(uuid.uuid4())
        
        # 1. æ·»åŠ åŒæ­¥å­—æ®µ
        sync_data = {
            **data,
            'id': record_id,
            'sync_status': 0,  # æœªåŒæ­¥
            'local_version': 1,
            'server_version': 0,
            'device_id': self.device_id,
            'created_at': datetime.utcnow().isoformat(),
            'updated_at': datetime.utcnow().isoformat()
        }
        
        # 2. æ’å…¥æœ¬åœ°æ•°æ®åº“
        self._insert_local_record(table_name, sync_data)
        
        # 3. æ·»åŠ åˆ°åŒæ­¥é˜Ÿåˆ—
        self._add_to_sync_queue(table_name, record_id, 'CREATE', sync_data)
        
        # 4. å°è¯•ç«‹å³åŒæ­¥ï¼ˆå¦‚æœæœ‰ç½‘ç»œï¼‰
        if self._is_online():
            self._sync_immediate()
        
        return record_id
    
    def update_record(self, table_name: str, record_id: str, data: Dict[str, Any]) -> bool:
        """æ›´æ–°è®°å½•"""
        # 1. è·å–å½“å‰è®°å½•
        current_record = self._get_local_record(table_name, record_id)
        if not current_record:
            return False
        
        # 2. æ£€æŸ¥æ˜¯å¦æœ‰æœåŠ¡å™¨æ›´æ–°ï¼ˆç‰ˆæœ¬å†²çªæ£€æµ‹ï¼‰
        if current_record.get('server_version', 0) > current_record.get('local_version', 1):
            # å­˜åœ¨å†²çªï¼Œæ ‡è®°å†²çªçŠ¶æ€
            self._mark_conflict(table_name, record_id, data)
            return False
        
        # 3. æ›´æ–°æœ¬åœ°æ•°æ®
        sync_data = {
            **current_record,
            **data,
            'local_version': current_record.get('local_version', 1) + 1,
            'sync_status': 0,  # æ ‡è®°ä¸ºæœªåŒæ­¥
            'updated_at': datetime.utcnow().isoformat()
        }
        
        self._update_local_record(table_name, record_id, sync_data)
        self._add_to_sync_queue(table_name, record_id, 'UPDATE', sync_data)
        
        if self._is_online():
            self._sync_immediate()
        
        return True
    
    def delete_record(self, table_name: str, record_id: str) -> bool:
        """åˆ é™¤è®°å½•ï¼ˆè½¯åˆ é™¤ï¼‰"""
        current_record = self._get_local_record(table_name, record_id)
        if not current_record:
            return False
        
        # è½¯åˆ é™¤æ ‡è®°
        sync_data = {
            **current_record,
            'is_deleted': True,
            'local_version': current_record.get('local_version', 1) + 1,
            'sync_status': 0,
            'updated_at': datetime.utcnow().isoformat()
        }
        
        self._update_local_record(table_name, record_id, sync_data)
        self._add_to_sync_queue(table_name, record_id, 'DELETE', sync_data)
        
        if self._is_online():
            self._sync_immediate()
        
        return True

class SyncService:
    def __init__(self, offline_service: OfflineDataService, api_client):
        self.offline_service = offline_service
        self.api_client = api_client
    
    async def sync_to_server(self) -> Dict[str, Any]:
        """å‘æœåŠ¡å™¨åŒæ­¥æœ¬åœ°æ›´æ”¹"""
        sync_queue = self._get_pending_sync_items()
        results = {
            'success': 0,
            'conflicts': 0,
            'errors': 0,
            'conflict_items': []
        }
        
        for item in sync_queue:
            try:
                # è·å–æœåŠ¡å™¨å½“å‰ç‰ˆæœ¬
                server_record = await self._get_server_record(
                    item['table_name'], 
                    item['record_id']
                )
                
                local_record = json.loads(item['data'])
                
                # å†²çªæ£€æµ‹
                conflict = self._detect_conflict(local_record, server_record)
                
                if conflict:
                    # å¤„ç†å†²çª
                    resolution = await self._resolve_conflict(
                        item['table_name'],
                        item['record_id'],
                        local_record,
                        server_record,
                        conflict
                    )
                    
                    if resolution['status'] == 'resolved':
                        results['success'] += 1
                    else:
                        results['conflicts'] += 1
                        results['conflict_items'].append(resolution)
                else:
                    # æ— å†²çªï¼Œç›´æ¥åŒæ­¥
                    success = await self._sync_record_to_server(item)
                    if success:
                        results['success'] += 1
                        self._mark_sync_complete(item['id'])
                    else:
                        results['errors'] += 1
                        
            except Exception as e:
                results['errors'] += 1
                print(f"åŒæ­¥é”™è¯¯: {e}")
        
        return results
    
    async def sync_from_server(self, last_sync_token: Optional[str] = None) -> Dict[str, Any]:
        """ä»æœåŠ¡å™¨åŒæ­¥æ›´æ”¹åˆ°æœ¬åœ°"""
        try:
            # è·å–å¢é‡æ›´æ–°
            server_changes = await self.api_client.get_incremental_changes(
                device_id=self.offline_service.device_id,
                since_token=last_sync_token
            )
            
            results = {
                'received': len(server_changes.get('changes', [])),
                'applied': 0,
                'conflicts': 0,
                'new_token': server_changes.get('next_token')
            }
            
            for change in server_changes.get('changes', []):
                # åº”ç”¨æœåŠ¡å™¨æ›´æ”¹åˆ°æœ¬åœ°
                conflict = await self._apply_server_change(change)
                
                if conflict:
                    results['conflicts'] += 1
                else:
                    results['applied'] += 1
            
            # æ›´æ–°æœ¬åœ°åŒæ­¥ä»¤ç‰Œ
            if results['new_token']:
                self._update_sync_token(results['new_token'])
            
            return results
            
        except Exception as e:
            print(f"ä»æœåŠ¡å™¨åŒæ­¥å¤±è´¥: {e}")
            return {'error': str(e)}
    
    def _detect_conflict(self, local_record: Dict, server_record: Dict) -> Optional[Dict]:
        """å†²çªæ£€æµ‹é€»è¾‘"""
        if not server_record:
            return None
        
        local_version = local_record.get('local_version', 1)
        server_version = server_record.get('version', 1)
        local_updated = local_record.get('updated_at')
        server_updated = server_record.get('updated_at')
        
        # 1. ç‰ˆæœ¬å†²çª
        if local_version > 1 and server_version > local_record.get('server_version', 0):
            return {
                'type': 'version_conflict',
                'local_version': local_version,
                'server_version': server_version
            }
        
        # 2. æ—¶é—´æˆ³å†²çªï¼ˆåŒæ—¶ç¼–è¾‘ï¼‰
        if local_updated and server_updated:
            local_time = datetime.fromisoformat(local_updated.replace('Z', '+00:00'))
            server_time = datetime.fromisoformat(server_updated.replace('Z', '+00:00'))
            
            # å¦‚æœä¸¤æ¬¡æ›´æ–°æ—¶é—´å¾ˆæ¥è¿‘ï¼ˆæ¯”å¦‚5åˆ†é’Ÿå†…ï¼‰ï¼Œè®¤ä¸ºæ˜¯å¹¶å‘ç¼–è¾‘
            time_diff = abs((local_time - server_time).total_seconds())
            if time_diff < 300:  # 5åˆ†é’Ÿ
                return {
                    'type': 'concurrent_edit',
                    'time_diff': time_diff
                }
        
        # 3. å­—æ®µå†²çªæ£€æµ‹
        field_conflicts = []
        key_fields = ['amount', 'record_type', 'category_id', 'description']
        
        for field in key_fields:
            if (local_record.get(field) != server_record.get(field) and 
                local_record.get(field) is not None and 
                server_record.get(field) is not None):
                field_conflicts.append({
                    'field': field,
                    'local_value': local_record.get(field),
                    'server_value': server_record.get(field)
                })
        
        if field_conflicts:
            return {
                'type': 'field_conflict',
                'conflicts': field_conflicts
            }
        
        return None
    
    async def _resolve_conflict(self, table_name: str, record_id: str, 
                              local_record: Dict, server_record: Dict, 
                              conflict: Dict) -> Dict[str, Any]:
        """å†²çªè§£å†³ç­–ç•¥"""
        
        # 1. è‡ªåŠ¨è§£å†³ç­–ç•¥
        auto_resolution = self._try_auto_resolve(conflict, local_record, server_record)
        if auto_resolution:
            return auto_resolution
        
        # 2. ä¸šåŠ¡è§„åˆ™è§£å†³
        business_resolution = self._apply_business_rules(
            table_name, conflict, local_record, server_record
        )
        if business_resolution:
            return business_resolution
        
        # 3. éœ€è¦ç”¨æˆ·æ‰‹åŠ¨è§£å†³
        return {
            'status': 'manual_required',
            'conflict': conflict,
            'local_record': local_record,
            'server_record': server_record,
            'suggested_resolution': self._suggest_resolution(conflict)
        }
    
    def _try_auto_resolve(self, conflict: Dict, local_record: Dict, server_record: Dict) -> Optional[Dict]:
        """è‡ªåŠ¨å†²çªè§£å†³"""
        
        if conflict['type'] == 'concurrent_edit':
            # å¯¹äºå¹¶å‘ç¼–è¾‘ï¼Œä¼˜å…ˆé€‰æ‹©é‡‘é¢æ›´å¤§çš„è®°å½•ï¼ˆå‡è®¾æ˜¯æ›´å‡†ç¡®çš„ï¼‰
            if local_record.get('amount', 0) != server_record.get('amount', 0):
                if local_record.get('amount', 0) > server_record.get('amount', 0):
                    return self._resolve_with_local(local_record)
                else:
                    return self._resolve_with_server(server_record)
        
        elif conflict['type'] == 'field_conflict':
            # å­—æ®µå†²çªçš„è‡ªåŠ¨è§£å†³è§„åˆ™
            merged_record = {**server_record}  # ä»¥æœåŠ¡å™¨è®°å½•ä¸ºåŸºç¡€
            
            for field_conflict in conflict['conflicts']:
                field = field_conflict['field']
                local_val = field_conflict['local_value']
                server_val = field_conflict['server_value']
                
                # ç‰¹æ®Šå­—æ®µçš„å¤„ç†é€»è¾‘
                if field == 'amount':
                    # é‡‘é¢å†²çªï¼Œé€‰æ‹©éé›¶å€¼
                    if local_val != 0 and server_val == 0:
                        merged_record[field] = local_val
                    elif server_val != 0 and local_val == 0:
                        merged_record[field] = server_val
                    else:
                        # éƒ½éé›¶ï¼Œæ— æ³•è‡ªåŠ¨è§£å†³
                        return None
                        
                elif field == 'description':
                    # æè¿°å†²çªï¼Œåˆå¹¶æè¿°
                    if local_val and server_val and local_val != server_val:
                        merged_record[field] = f"{server_val} | {local_val}"
                    elif local_val and not server_val:
                        merged_record[field] = local_val
            
            return {
                'status': 'resolved',
                'strategy': 'auto_merge',
                'resolved_record': merged_record
            }
        
        return None
    
    def _apply_business_rules(self, table_name: str, conflict: Dict, 
                            local_record: Dict, server_record: Dict) -> Optional[Dict]:
        """åº”ç”¨ä¸šåŠ¡è§„åˆ™è§£å†³å†²çª"""
        
        if table_name == 'records':
            # è®°è´¦è®°å½•çš„ä¸šåŠ¡è§„åˆ™
            
            # è§„åˆ™1ï¼šåˆ é™¤æ“ä½œä¼˜å…ˆçº§æœ€é«˜
            if local_record.get('is_deleted') or server_record.get('is_deleted'):
                return {
                    'status': 'resolved',
                    'strategy': 'deletion_priority',
                    'resolved_record': {**server_record, 'is_deleted': True}
                }
            
            # è§„åˆ™2ï¼šåˆ›å»ºè€…æœ‰æ›´é«˜æƒé™ä¿®æ”¹è‡ªå·±çš„è®°å½•
            if (local_record.get('creator_id') == local_record.get('last_editor_id') and
                server_record.get('creator_id') != server_record.get('last_editor_id')):
                return self._resolve_with_local(local_record)
            
            # è§„åˆ™3ï¼šæœ€è¿‘çš„ä¿®æ”¹æ—¶é—´ä¼˜å…ˆï¼ˆå¦‚æœæ—¶é—´å·®è¶…è¿‡1å°æ—¶ï¼‰
            local_time = datetime.fromisoformat(local_record.get('updated_at', ''))
            server_time = datetime.fromisoformat(server_record.get('updated_at', ''))
            
            if abs((local_time - server_time).total_seconds()) > 3600:  # 1å°æ—¶
                if local_time > server_time:
                    return self._resolve_with_local(local_record)
                else:
                    return self._resolve_with_server(server_record)
        
        return None
```

## ğŸ“± å®¢æˆ·ç«¯å®ç°

### 1. Flutterç¦»çº¿å­˜å‚¨å®ç°

```dart
// lib/services/offline_database_service.dart
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'dart:convert';

class OfflineDatabaseService {
  static Database? _database;
  static const String _databaseName = 'accounting_offline.db';
  static const int _databaseVersion = 1;
  
  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDatabase();
    return _database!;
  }
  
  Future<Database> _initDatabase() async {
    String path = join(await getDatabasesPath(), _databaseName);
    return await openDatabase(
      path,
      version: _databaseVersion,
      onCreate: _onCreate,
      onUpgrade: _onUpgrade,
    );
  }
  
  Future<void> _onCreate(Database db, int version) async {
    // åˆ›å»ºæœ¬åœ°è¡¨ç»“æ„
    await db.execute('''
      CREATE TABLE records (
        id TEXT PRIMARY KEY,
        account_id TEXT NOT NULL,
        record_type TEXT NOT NULL,
        amount REAL NOT NULL,
        record_date TEXT NOT NULL,
        description TEXT,
        category_id TEXT,
        payment_account_id TEXT,
        
        -- åŒæ­¥ç›¸å…³å­—æ®µ
        sync_status INTEGER DEFAULT 0,
        local_version INTEGER DEFAULT 1,
        server_version INTEGER DEFAULT 0,
        last_sync_at TEXT,
        conflict_data TEXT,
        device_id TEXT,
        
        created_at TEXT DEFAULT CURRENT_TIMESTAMP,
        updated_at TEXT DEFAULT CURRENT_TIMESTAMP,
        is_deleted INTEGER DEFAULT 0
      )
    ''');
    
    await db.execute('''
      CREATE TABLE sync_queue (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        table_name TEXT NOT NULL,
        record_id TEXT NOT NULL,
        operation TEXT NOT NULL,
        data TEXT,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP,
        retry_count INTEGER DEFAULT 0,
        status INTEGER DEFAULT 0
      )
    ''');
    
    // åˆ›å»ºç´¢å¼•
    await db.execute('CREATE INDEX idx_records_account ON records(account_id)');
    await db.execute('CREATE INDEX idx_records_sync ON records(sync_status)');
    await db.execute('CREATE INDEX idx_sync_queue_status ON sync_queue(status)');
  }
  
  // ç¦»çº¿æ•°æ®åˆ†ææ–¹æ³•
  Future<Map<String, dynamic>> getOfflineAnalytics(String accountId) async {
    final db = await database;
    
    // è·å–æœ¬æœˆæ”¶æ”¯ç»Ÿè®¡
    final currentMonth = DateTime.now().month;
    final currentYear = DateTime.now().year;
    
    final incomeResult = await db.rawQuery('''
      SELECT SUM(amount) as total_income
      FROM records 
      WHERE account_id = ? 
        AND record_type = 'income'
        AND strftime('%Y', record_date) = ?
        AND strftime('%m', record_date) = ?
        AND is_deleted = 0
    ''', [accountId, currentYear.toString(), currentMonth.toString().padLeft(2, '0')]);
    
    final expenseResult = await db.rawQuery('''
      SELECT SUM(amount) as total_expense
      FROM records 
      WHERE account_id = ? 
        AND record_type = 'expense'
        AND strftime('%Y', record_date) = ?
        AND strftime('%m', record_date) = ?
        AND is_deleted = 0
    ''', [accountId, currentYear.toString(), currentMonth.toString().padLeft(2, '0')]);
    
    // åˆ†ç±»æ”¯å‡ºç»Ÿè®¡
    final categoryResult = await db.rawQuery('''
      SELECT 
        c.name as category_name,
        SUM(r.amount) as total_amount,
        COUNT(*) as record_count
      FROM records r
      LEFT JOIN categories c ON r.category_id = c.id
      WHERE r.account_id = ?
        AND r.record_type = 'expense'
        AND strftime('%Y', r.record_date) = ?
        AND strftime('%m', r.record_date) = ?
        AND r.is_deleted = 0
      GROUP BY r.category_id, c.name
      ORDER BY total_amount DESC
    ''', [accountId, currentYear.toString(), currentMonth.toString().padLeft(2, '0')]);
    
    // æœ€è¿‘7å¤©è¶‹åŠ¿
    final trendResult = await db.rawQuery('''
      SELECT 
        DATE(record_date) as date,
        SUM(CASE WHEN record_type = 'income' THEN amount ELSE 0 END) as daily_income,
        SUM(CASE WHEN record_type = 'expense' THEN amount ELSE 0 END) as daily_expense
      FROM records
      WHERE account_id = ?
        AND record_date >= date('now', '-7 days')
        AND is_deleted = 0
      GROUP BY DATE(record_date)
      ORDER BY date
    ''', [accountId]);
    
    return {
      'monthly_income': incomeResult.first['total_income'] ?? 0.0,
      'monthly_expense': expenseResult.first['total_expense'] ?? 0.0,
      'category_breakdown': categoryResult,
      'weekly_trend': trendResult,
      'last_updated': DateTime.now().toIso8601String(),
    };
  }
}

// lib/services/sync_service.dart
class SyncService {
  final OfflineDatabaseService _dbService;
  final ApiService _apiService;
  
  SyncService(this._dbService, this._apiService);
  
  // åå°åŒæ­¥ä»»åŠ¡
  Future<void> startBackgroundSync() async {
    Timer.periodic(Duration(minutes: 5), (timer) async {
      if (await _isOnline()) {
        await performSync();
      }
    });
  }
  
  Future<SyncResult> performSync() async {
    try {
      // 1. ä¸Šä¼ æœ¬åœ°æ›´æ”¹
      final uploadResult = await _uploadLocalChanges();
      
      // 2. ä¸‹è½½æœåŠ¡å™¨æ›´æ”¹
      final downloadResult = await _downloadServerChanges();
      
      // 3. å¤„ç†å†²çª
      final conflictResult = await _resolveConflicts();
      
      return SyncResult(
        uploadCount: uploadResult.successCount,
        downloadCount: downloadResult.receivedCount,
        conflictCount: conflictResult.conflictCount,
        success: true,
      );
    } catch (e) {
      return SyncResult(success: false, error: e.toString());
    }
  }
  
  Future<bool> _isOnline() async {
    var connectivityResult = await Connectivity().checkConnectivity();
    return connectivityResult != ConnectivityResult.none;
  }
}
```

## ğŸ”§ å†²çªè§£å†³UI

### 1. å†²çªè§£å†³ç•Œé¢è®¾è®¡

```dart
// lib/screens/conflict_resolution_screen.dart
class ConflictResolutionScreen extends StatefulWidget {
  final List<ConflictItem> conflicts;
  
  @override
  _ConflictResolutionScreenState createState() => _ConflictResolutionScreenState();
}

class _ConflictResolutionScreenState extends State<ConflictResolutionScreen> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('è§£å†³æ•°æ®å†²çª'),
        subtitle: Text('å‘ç° ${widget.conflicts.length} ä¸ªå†²çª'),
      ),
      body: ListView.builder(
        itemCount: widget.conflicts.length,
        itemBuilder: (context, index) {
          final conflict = widget.conflicts[index];
          return ConflictItemCard(
            conflict: conflict,
            onResolved: (resolution) => _resolveConflict(conflict, resolution),
          );
        },
      ),
    );
  }
  
  void _resolveConflict(ConflictItem conflict, ConflictResolution resolution) {
    // å¤„ç†ç”¨æˆ·é€‰æ‹©çš„å†²çªè§£å†³æ–¹æ¡ˆ
    setState(() {
      widget.conflicts.remove(conflict);
    });
  }
}

class ConflictItemCard extends StatelessWidget {
  final ConflictItem conflict;
  final Function(ConflictResolution) onResolved;
  
  @override
  Widget build(BuildContext context) {
    return Card(
      margin: EdgeInsets.all(16),
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('è®°è´¦è®°å½•å†²çª', style: TextStyle(fontWeight: FontWeight.bold)),
            SizedBox(height: 16),
            
            // æ˜¾ç¤ºæœ¬åœ°ç‰ˆæœ¬
            Container(
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.blue.shade50,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('æœ¬åœ°ç‰ˆæœ¬ (æœ¬è®¾å¤‡)', style: TextStyle(fontWeight: FontWeight.bold)),
                  Text('é‡‘é¢: Â¥${conflict.localRecord.amount}'),
                  Text('æè¿°: ${conflict.localRecord.description}'),
                  Text('ä¿®æ”¹æ—¶é—´: ${_formatDate(conflict.localRecord.updatedAt)}'),
                ],
              ),
            ),
            
            SizedBox(height: 12),
            
            // æ˜¾ç¤ºæœåŠ¡å™¨ç‰ˆæœ¬
            Container(
              padding: EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.orange.shade50,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('æœåŠ¡å™¨ç‰ˆæœ¬ (å…¶ä»–è®¾å¤‡)', style: TextStyle(fontWeight: FontWeight.bold)),
                  Text('é‡‘é¢: Â¥${conflict.serverRecord.amount}'),
                  Text('æè¿°: ${conflict.serverRecord.description}'),
                  Text('ä¿®æ”¹æ—¶é—´: ${_formatDate(conflict.serverRecord.updatedAt)}'),
                ],
              ),
            ),
            
            SizedBox(height: 16),
            
            // è§£å†³æ–¹æ¡ˆé€‰æ‹©
            Row(
              children: [
                Expanded(
                  child: ElevatedButton(
                    onPressed: () => onResolved(ConflictResolution.useLocal()),
                    child: Text('ä½¿ç”¨æœ¬åœ°ç‰ˆæœ¬'),
                  ),
                ),
                SizedBox(width: 12),
                Expanded(
                  child: ElevatedButton(
                    onPressed: () => onResolved(ConflictResolution.useServer()),
                    style: ElevatedButton.styleFrom(backgroundColor: Colors.orange),
                    child: Text('ä½¿ç”¨æœåŠ¡å™¨ç‰ˆæœ¬'),
                  ),
                ),
              ],
            ),
            
            SizedBox(height: 8),
            
            Center(
              child: TextButton(
                onPressed: () => _showMergeDialog(context, conflict),
                child: Text('æ‰‹åŠ¨åˆå¹¶'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

## ğŸ“Š åŒæ­¥çŠ¶æ€ç›‘æ§

### 1. åŒæ­¥çŠ¶æ€æ˜¾ç¤º

```dart
// lib/widgets/sync_status_widget.dart
class SyncStatusWidget extends StatelessWidget {
  final SyncStatus status;
  
  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      decoration: BoxDecoration(
        color: _getStatusColor(status),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            _getStatusIcon(status),
            size: 16,
            color: Colors.white,
          ),
          SizedBox(width: 6),
          Text(
            _getStatusText(status),
            style: TextStyle(color: Colors.white, fontSize: 12),
          ),
        ],
      ),
    );
  }
  
  Color _getStatusColor(SyncStatus status) {
    switch (status) {
      case SyncStatus.synced:
        return Colors.green;
      case SyncStatus.pending:
        return Colors.orange;
      case SyncStatus.syncing:
        return Colors.blue;
      case SyncStatus.conflict:
        return Colors.red;
      case SyncStatus.offline:
        return Colors.grey;
      default:
        return Colors.grey;
    }
  }
  
  IconData _getStatusIcon(SyncStatus status) {
    switch (status) {
      case SyncStatus.synced:
        return Icons.check_circle;
      case SyncStatus.pending:
        return Icons.schedule;
      case SyncStatus.syncing:
        return Icons.sync;
      case SyncStatus.conflict:
        return Icons.warning;
      case SyncStatus.offline:
        return Icons.cloud_off;
      default:
        return Icons.help;
    }
  }
  
  String _getStatusText(SyncStatus status) {
    switch (status) {
      case SyncStatus.synced:
        return 'å·²åŒæ­¥';
      case SyncStatus.pending:
        return 'å¾…åŒæ­¥';
      case SyncStatus.syncing:
        return 'åŒæ­¥ä¸­';
      case SyncStatus.conflict:
        return 'æœ‰å†²çª';
      case SyncStatus.offline:
        return 'ç¦»çº¿';
      default:
        return 'æœªçŸ¥';
    }
  }
}

// åŒæ­¥è¿›åº¦æŒ‡ç¤ºå™¨
class SyncProgressIndicator extends StatelessWidget {
  final int totalItems;
  final int syncedItems;
  final bool isActive;
  
  const SyncProgressIndicator({
    Key? key,
    required this.totalItems,
    required this.syncedItems,
    this.isActive = false,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    final progress = totalItems > 0 ? syncedItems / totalItems : 0.0;
    
    return Container(
      padding: EdgeInsets.all(16),
      child: Column(
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                'åŒæ­¥è¿›åº¦',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              Text('$syncedItems / $totalItems'),
            ],
          ),
          SizedBox(height: 8),
          LinearProgressIndicator(
            value: progress,
            backgroundColor: Colors.grey[300],
            valueColor: AlwaysStoppedAnimation<Color>(
              isActive ? Colors.blue : Colors.green,
            ),
          ),
          if (isActive) ...[
            SizedBox(height: 8),
            Text(
              'æ­£åœ¨åŒæ­¥æ•°æ®...',
              style: TextStyle(color: Colors.grey[600]),
            ),
          ],
        ],
      ),
    );
  }
}
```

## ğŸ¯ æ™ºèƒ½åŒæ­¥ç­–ç•¥

### 1. åŒæ­¥ä¼˜å…ˆçº§å’Œç­–ç•¥

```python
# app/services/smart_sync_service.py
from enum import Enum
from typing import Dict, List, Any, Optional
import json
from datetime import datetime, timedelta

class SyncPriority(Enum):
    CRITICAL = 1    # ç«‹å³åŒæ­¥ï¼ˆåˆ é™¤æ“ä½œã€é‡è¦ä¿®æ”¹ï¼‰
    HIGH = 2        # é«˜ä¼˜å…ˆçº§ï¼ˆæ–°å¢è®°å½•ã€é‡‘é¢ä¿®æ”¹ï¼‰
    NORMAL = 3      # æ­£å¸¸ä¼˜å…ˆçº§ï¼ˆæè¿°ä¿®æ”¹ã€åˆ†ç±»å˜æ›´ï¼‰
    LOW = 4         # ä½ä¼˜å…ˆçº§ï¼ˆæ ‡ç­¾ä¿®æ”¹ã€å¤‡æ³¨ï¼‰

class SmartSyncService:
    def __init__(self, offline_service, api_client):
        self.offline_service = offline_service
        self.api_client = api_client
        self.sync_strategies = self._init_sync_strategies()
    
    def _init_sync_strategies(self) -> Dict[str, Any]:
        """åˆå§‹åŒ–åŒæ­¥ç­–ç•¥é…ç½®"""
        return {
            'batch_size': 50,           # æ‰¹é‡åŒæ­¥å¤§å°
            'retry_count': 3,           # é‡è¯•æ¬¡æ•°
            'retry_delay': [1, 5, 15],  # é‡è¯•å»¶è¿Ÿï¼ˆç§’ï¼‰
            'conflict_auto_resolve': True,  # è‡ªåŠ¨è§£å†³å†²çª
            'offline_retention_days': 30,   # ç¦»çº¿æ•°æ®ä¿ç•™å¤©æ•°
            'sync_frequency': {
                'online': 60,           # åœ¨çº¿æ—¶åŒæ­¥é¢‘ç‡ï¼ˆç§’ï¼‰
                'offline_check': 300    # ç¦»çº¿æ£€æŸ¥é¢‘ç‡ï¼ˆç§’ï¼‰
            }
        }
    
    async def intelligent_sync(self) -> Dict[str, Any]:
        """æ™ºèƒ½åŒæ­¥ï¼šæ ¹æ®ç½‘ç»œçŠ¶å†µã€æ•°æ®é‡è¦æ€§ç­‰å› ç´ ä¼˜åŒ–åŒæ­¥"""
        
        # 1. æ£€æŸ¥ç½‘ç»œçŠ¶å†µ
        network_quality = await self._assess_network_quality()
        
        # 2. è·å–å¾…åŒæ­¥æ•°æ®å¹¶åˆ†ç±»
        sync_queue = self._get_prioritized_sync_queue()
        
        # 3. æ ¹æ®ç½‘ç»œçŠ¶å†µè°ƒæ•´åŒæ­¥ç­–ç•¥
        strategy = self._adapt_sync_strategy(network_quality, len(sync_queue))
        
        # 4. æ‰§è¡Œåˆ†æ‰¹åŒæ­¥
        results = await self._execute_prioritized_sync(sync_queue, strategy)
        
        return results
    
    def _get_prioritized_sync_queue(self) -> List[Dict[str, Any]]:
        """è·å–æŒ‰ä¼˜å…ˆçº§æ’åºçš„åŒæ­¥é˜Ÿåˆ—"""
        queue = self.offline_service._get_pending_sync_items()
        
        # ä¸ºæ¯ä¸ªé¡¹ç›®åˆ†é…ä¼˜å…ˆçº§
        for item in queue:
            item['priority'] = self._calculate_priority(item)
            item['estimated_size'] = self._estimate_data_size(item)
        
        # æŒ‰ä¼˜å…ˆçº§å’Œæ—¶é—´æ’åº
        return sorted(queue, key=lambda x: (
            x['priority'].value,           # ä¼˜å…ˆçº§
            x['created_at'],              # åˆ›å»ºæ—¶é—´
            x['estimated_size']           # æ•°æ®å¤§å°
        ))
    
    def _calculate_priority(self, item: Dict[str, Any]) -> SyncPriority:
        """è®¡ç®—åŒæ­¥é¡¹çš„ä¼˜å…ˆçº§"""
        operation = item.get('operation', '')
        data = json.loads(item.get('data', '{}'))
        table_name = item.get('table_name', '')
        
        # åˆ é™¤æ“ä½œ - æœ€é«˜ä¼˜å…ˆçº§
        if operation == 'DELETE':
            return SyncPriority.CRITICAL
        
        # æ–°å¢é‡è¦è®°å½•
        if operation == 'CREATE' and table_name == 'records':
            amount = data.get('amount', 0)
            if amount > 1000:  # å¤§é¢äº¤æ˜“
                return SyncPriority.HIGH
            return SyncPriority.NORMAL
        
        # é‡‘é¢ä¿®æ”¹
        if operation == 'UPDATE' and 'amount' in data:
            return SyncPriority.HIGH
        
        # å…¶ä»–ä¿®æ”¹
        if operation == 'UPDATE':
            # é‡è¦å­—æ®µä¿®æ”¹
            important_fields = ['record_type', 'category_id', 'payment_account_id']
            if any(field in data for field in important_fields):
                return SyncPriority.HIGH
            return SyncPriority.NORMAL
        
        return SyncPriority.LOW
    
    async def _assess_network_quality(self) -> Dict[str, Any]:
        """è¯„ä¼°ç½‘ç»œè´¨é‡"""
        try:
            import time
            start_time = time.time()
            
            # å‘é€å°çš„æµ‹è¯•è¯·æ±‚
            response = await self.api_client.ping()
            
            latency = (time.time() - start_time) * 1000  # æ¯«ç§’
            
            # æ ¹æ®å»¶è¿Ÿè¯„ä¼°ç½‘ç»œè´¨é‡
            if latency < 100:
                quality = 'excellent'
                recommended_batch_size = 100
            elif latency < 300:
                quality = 'good'
                recommended_batch_size = 50
            elif latency < 1000:
                quality = 'fair'
                recommended_batch_size = 20
            else:
                quality = 'poor'
                recommended_batch_size = 10
            
            return {
                'quality': quality,
                'latency': latency,
                'recommended_batch_size': recommended_batch_size,
                'timestamp': datetime.utcnow().isoformat()
            }
        except Exception:
            return {
                'quality': 'offline',
                'latency': float('inf'),
                'recommended_batch_size': 0,
                'timestamp': datetime.utcnow().isoformat()
            }
    
    def _adapt_sync_strategy(self, network_quality: Dict, queue_length: int) -> Dict[str, Any]:
        """æ ¹æ®ç½‘ç»œçŠ¶å†µè°ƒæ•´åŒæ­¥ç­–ç•¥"""
        base_strategy = self.sync_strategies.copy()
        
        if network_quality['quality'] == 'offline':
            return {**base_strategy, 'enabled': False}
        
        # æ ¹æ®ç½‘ç»œè´¨é‡è°ƒæ•´æ‰¹é‡å¤§å°
        batch_size = min(
            network_quality['recommended_batch_size'],
            base_strategy['batch_size']
        )
        
        # æ ¹æ®é˜Ÿåˆ—é•¿åº¦è°ƒæ•´ç­–ç•¥
        if queue_length > 500:
            # å¤§é‡æ•°æ®å¾…åŒæ­¥ï¼Œä¼˜å…ˆå¤„ç†é«˜ä¼˜å…ˆçº§
            batch_size = max(batch_size // 2, 10)
            priority_filter = [SyncPriority.CRITICAL, SyncPriority.HIGH]
        elif queue_length > 100:
            priority_filter = [SyncPriority.CRITICAL, SyncPriority.HIGH, SyncPriority.NORMAL]
        else:
            priority_filter = None  # å¤„ç†æ‰€æœ‰ä¼˜å…ˆçº§
        
        return {
            **base_strategy,
            'batch_size': batch_size,
            'priority_filter': priority_filter,
            'network_quality': network_quality,
            'enabled': True
        }
    
    async def _execute_prioritized_sync(self, sync_queue: List[Dict], strategy: Dict) -> Dict[str, Any]:
        """æ‰§è¡Œä¼˜å…ˆçº§åŒæ­¥"""
        if not strategy.get('enabled', True):
            return {'status': 'skipped', 'reason': 'offline'}
        
        results = {
            'total_items': len(sync_queue),
            'processed': 0,
            'successful': 0,
            'failed': 0,
            'conflicts': 0,
            'skipped': 0,
            'batches': []
        }
        
        # æŒ‰ä¼˜å…ˆçº§è¿‡æ»¤
        if strategy.get('priority_filter'):
            sync_queue = [
                item for item in sync_queue 
                if item['priority'] in strategy['priority_filter']
            ]
        
        # åˆ†æ‰¹å¤„ç†
        batch_size = strategy['batch_size']
        for i in range(0, len(sync_queue), batch_size):
            batch = sync_queue[i:i + batch_size]
            batch_result = await self._sync_batch(batch, strategy)
            results['batches'].append(batch_result)
            
            # æ›´æ–°æ€»è®¡
            results['processed'] += batch_result['processed']
            results['successful'] += batch_result['successful']
            results['failed'] += batch_result['failed']
            results['conflicts'] += batch_result['conflicts']
            
            # å¦‚æœç½‘ç»œçŠ¶å†µå˜å·®ï¼Œè°ƒæ•´ç­–ç•¥
            if batch_result.get('network_degraded'):
                strategy['batch_size'] = max(strategy['batch_size'] // 2, 5)
        
        return results
    
    async def _sync_batch(self, batch: List[Dict], strategy: Dict) -> Dict[str, Any]:
        """åŒæ­¥ä¸€ä¸ªæ‰¹æ¬¡çš„æ•°æ®"""
        batch_result = {
            'size': len(batch),
            'processed': 0,
            'successful': 0,
            'failed': 0,
            'conflicts': 0,
            'start_time': datetime.utcnow(),
            'network_degraded': False
        }
        
        try:
            # æ‰¹é‡å‘é€åˆ°æœåŠ¡å™¨
            response = await self.api_client.batch_sync(batch)
            
            # å¤„ç†å“åº”
            for i, item_result in enumerate(response.get('results', [])):
                batch_result['processed'] += 1
                original_item = batch[i]
                
                if item_result['status'] == 'success':
                    batch_result['successful'] += 1
                    self._mark_sync_complete(original_item['id'], item_result.get('server_version'))
                    
                elif item_result['status'] == 'conflict':
                    batch_result['conflicts'] += 1
                    await self._handle_batch_conflict(original_item, item_result)
                    
                else:  # failed
                    batch_result['failed'] += 1
                    self._mark_sync_failed(original_item['id'], item_result.get('error'))
        
        except Exception as e:
            # ç½‘ç»œå¼‚å¸¸ï¼Œæ ‡è®°æ•´ä¸ªæ‰¹æ¬¡å¤±è´¥
            batch_result['failed'] = len(batch)
            batch_result['network_degraded'] = True
            
            # å¢åŠ é‡è¯•è®¡æ•°
            for item in batch:
                self._increment_retry_count(item['id'])
        
        batch_result['end_time'] = datetime.utcnow()
        batch_result['duration'] = (
            batch_result['end_time'] - batch_result['start_time']
        ).total_seconds()
        
        return batch_result

class ConflictResolver:
    """å†²çªè§£å†³å™¨"""
    
    def __init__(self):
        self.auto_resolution_rules = self._init_auto_rules()
    
    def _init_auto_rules(self) -> Dict[str, Any]:
        """åˆå§‹åŒ–è‡ªåŠ¨è§£å†³è§„åˆ™"""
        return {
            'records': {
                'deletion_wins': True,      # åˆ é™¤æ“ä½œä¼˜å…ˆ
                'creator_privilege': True,  # åˆ›å»ºè€…ç‰¹æƒ
                'recent_wins_threshold': 3600,  # 1å°æ—¶å†…çš„ä¿®æ”¹ä¼˜å…ˆ
                'amount_non_zero_wins': True,   # éé›¶é‡‘é¢ä¼˜å…ˆ
                'merge_descriptions': True      # åˆå¹¶æè¿°å­—æ®µ
            },
            'accounts': {
                'owner_privilege': True,    # æ‰€æœ‰è€…ç‰¹æƒ
                'recent_wins_threshold': 7200,  # 2å°æ—¶
            }
        }
    
    def resolve_conflict_automatically(self, table_name: str, local_data: Dict, 
                                     server_data: Dict, conflict_type: str) -> Optional[Dict]:
        """è‡ªåŠ¨è§£å†³å†²çª"""
        rules = self.auto_resolution_rules.get(table_name, {})
        
        # åˆ é™¤ä¼˜å…ˆè§„åˆ™
        if rules.get('deletion_wins'):
            if local_data.get('is_deleted') or server_data.get('is_deleted'):
                return self._create_resolution('deletion_priority', {
                    **server_data,
                    'is_deleted': True
                })
        
        # åˆ›å»ºè€…ç‰¹æƒè§„åˆ™
        if rules.get('creator_privilege') and table_name == 'records':
            local_creator = local_data.get('creator_id')
            local_editor = local_data.get('last_editor_id', local_creator)
            server_editor = server_data.get('last_editor_id')
            
            if local_creator == local_editor and local_creator != server_editor:
                return self._create_resolution('creator_privilege', local_data)
        
        # æ—¶é—´ä¼˜å…ˆè§„åˆ™
        recent_threshold = rules.get('recent_wins_threshold', 3600)
        if recent_threshold:
            local_time = self._parse_datetime(local_data.get('updated_at'))
            server_time = self._parse_datetime(server_data.get('updated_at'))
            
            if local_time and server_time:
                time_diff = abs((local_time - server_time).total_seconds())
                if time_diff > recent_threshold:
                    winner = local_data if local_time > server_time else server_data
                    return self._create_resolution('time_priority', winner)
        
        # å­—æ®µçº§æ™ºèƒ½åˆå¹¶
        if rules.get('merge_descriptions') and conflict_type == 'field_conflict':
            merged = self._merge_fields(local_data, server_data, rules)
            if merged:
                return self._create_resolution('smart_merge', merged)
        
        return None
    
    def _merge_fields(self, local_data: Dict, server_data: Dict, rules: Dict) -> Optional[Dict]:
        """æ™ºèƒ½å­—æ®µåˆå¹¶"""
        merged = {**server_data}  # ä»¥æœåŠ¡å™¨æ•°æ®ä¸ºåŸºç¡€
        
        # é‡‘é¢å­—æ®µç‰¹æ®Šå¤„ç†
        local_amount = local_data.get('amount', 0)
        server_amount = server_data.get('amount', 0)
        
        if rules.get('amount_non_zero_wins'):
            if local_amount != 0 and server_amount == 0:
                merged['amount'] = local_amount
            elif server_amount != 0 and local_amount == 0:
                merged['amount'] = server_amount
            elif local_amount != server_amount and both_non_zero(local_amount, server_amount):
                # éƒ½éé›¶ä¸”ä¸åŒï¼Œæ— æ³•è‡ªåŠ¨è§£å†³
                return None
        
        # æè¿°å­—æ®µåˆå¹¶
        local_desc = local_data.get('description', '').strip()
        server_desc = server_data.get('description', '').strip()
        
        if local_desc and server_desc and local_desc != server_desc:
            # æ™ºèƒ½åˆå¹¶æè¿°
            if local_desc in server_desc:
                merged['description'] = server_desc
            elif server_desc in local_desc:
                merged['description'] = local_desc
            else:
                merged['description'] = f"{server_desc} | {local_desc}"
        elif local_desc and not server_desc:
            merged['description'] = local_desc
        
        return merged
    
    def _create_resolution(self, strategy: str, resolved_data: Dict) -> Dict[str, Any]:
        """åˆ›å»ºè§£å†³æ–¹æ¡ˆ"""
        return {
            'status': 'auto_resolved',
            'strategy': strategy,
            'resolved_data': resolved_data,
            'timestamp': datetime.utcnow().isoformat()
        }

def both_non_zero(a, b) -> bool:
    """æ£€æŸ¥ä¸¤ä¸ªæ•°éƒ½éé›¶"""
    return a != 0 and b != 0
```

## ğŸ“± ç”¨æˆ·ä½“éªŒä¼˜åŒ–

### 1. ç¦»çº¿æç¤ºå’Œå¼•å¯¼

```dart
// lib/widgets/offline_banner.dart
class OfflineBanner extends StatelessWidget {
  final int pendingCount;
  final VoidCallback? onSyncPressed;
  
  const OfflineBanner({
    Key? key,
    this.pendingCount = 0,
    this.onSyncPressed,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    if (pendingCount == 0) return SizedBox.shrink();
    
    return Container(
      width: double.infinity,
      padding: EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.orange.shade100,
        border: Border(
          bottom: BorderSide(color: Colors.orange.shade300),
        ),
      ),
      child: Row(
        children: [
          Icon(
            Icons.cloud_off,
            color: Colors.orange.shade700,
            size: 20,
          ),
          SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'ç¦»çº¿æ¨¡å¼',
                  style: TextStyle(
                    fontWeight: FontWeight.bold,
                    color: Colors.orange.shade800,
                  ),
                ),
                Text(
                  'æœ‰ $pendingCount æ¡è®°å½•å¾…åŒæ­¥',
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.orange.shade700,
                  ),
                ),
              ],
            ),
          ),
          if (onSyncPressed != null)
            TextButton(
              onPressed: onSyncPressed,
              child: Text(
                'ç«‹å³åŒæ­¥',
                style: TextStyle(color: Colors.orange.shade800),
              ),
            ),
        ],
      ),
    );
  }
}

// åŒæ­¥ç¡®è®¤å¯¹è¯æ¡†
class SyncConfirmationDialog extends StatelessWidget {
  final int pendingCount;
  final int conflictCount;
  
  const SyncConfirmationDialog({
    Key? key,
    required this.pendingCount,
    this.conflictCount = 0,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: Text('æ•°æ®åŒæ­¥'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('å³å°†åŒæ­¥ $pendingCount æ¡è®°å½•åˆ°äº‘ç«¯'),
          if (conflictCount > 0) ...[
            SizedBox(height: 8),
            Container(
              padding: EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: Colors.red.shade50,
                borderRadius: BorderRadius.circular(4),
              ),
              child: Row(
                children: [
                  Icon(Icons.warning, color: Colors.red, size: 16),
                  SizedBox(width: 8),
                  Text(
                    'å‘ç° $conflictCount ä¸ªå†²çªéœ€è¦å¤„ç†',
                    style: TextStyle(color: Colors.red.shade700),
                  ),
                ],
              ),
            ),
          ],
          SizedBox(height: 12),
          Text(
            'åŒæ­¥è¿‡ç¨‹ä¸­å¯èƒ½ä¼šæ¶ˆè€—æµé‡ï¼Œå»ºè®®åœ¨WiFiç¯å¢ƒä¸‹è¿›è¡Œã€‚',
            style: TextStyle(
              fontSize: 12,
              color: Colors.grey[600],
            ),
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(false),
          child: Text('å–æ¶ˆ'),
        ),
        ElevatedButton(
          onPressed: () => Navigator.of(context).pop(true),
          child: Text('å¼€å§‹åŒæ­¥'),
        ),
      ],
    );
  }
}
```

## ğŸ”„ æœ€ä½³å®è·µæ€»ç»“

### 1. æ•°æ®åŒæ­¥æ ¸å¿ƒåŸåˆ™

1. **ç¦»çº¿ä¼˜å…ˆ**ï¼šæ‰€æœ‰åŠŸèƒ½éƒ½èƒ½ç¦»çº¿å·¥ä½œ
2. **å¢é‡åŒæ­¥**ï¼šåªä¼ è¾“å˜æ›´æ•°æ®ï¼ŒèŠ‚çœæµé‡
3. **æ™ºèƒ½å†²çªè§£å†³**ï¼šè‡ªåŠ¨è§£å†³å¤§éƒ¨åˆ†å†²çªï¼Œå‡å°‘ç”¨æˆ·å¹²é¢„
4. **æ•°æ®å®Œæ•´æ€§**ï¼šç¡®ä¿åŒæ­¥è¿‡ç¨‹ä¸­æ•°æ®ä¸ä¸¢å¤±
5. **ç”¨æˆ·ä½“éªŒ**ï¼šåŒæ­¥è¿‡ç¨‹å¯¹ç”¨æˆ·é€æ˜ï¼Œä¸é˜»å¡æ“ä½œ

### 2. æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **åˆ†æ‰¹åŒæ­¥**ï¼šå¤§é‡æ•°æ®åˆ†æ‰¹å¤„ç†ï¼Œé¿å…è¶…æ—¶
2. **å‹ç¼©ä¼ è¾“**ï¼šå¯¹JSONæ•°æ®è¿›è¡Œgzipå‹ç¼©
3. **å·®é‡æ›´æ–°**ï¼šåªä¼ è¾“å˜æ›´çš„å­—æ®µ
4. **åå°åŒæ­¥**ï¼šåˆ©ç”¨åå°ä»»åŠ¡è¿›è¡ŒåŒæ­¥
5. **ç½‘ç»œè‡ªé€‚åº”**ï¼šæ ¹æ®ç½‘ç»œè´¨é‡è°ƒæ•´åŒæ­¥ç­–ç•¥

### 3. å†²çªè§£å†³ç­–ç•¥

1. **è‡ªåŠ¨è§£å†³**ï¼š90%çš„å†²çªå¯ä»¥è‡ªåŠ¨è§£å†³
2. **ä¸šåŠ¡è§„åˆ™**ï¼šåŸºäºä¸šåŠ¡é€»è¾‘çš„å†²çªè§£å†³
3. **ç”¨æˆ·é€‰æ‹©**ï¼šå¤æ‚å†²çªè®©ç”¨æˆ·å†³å®š
4. **æ™ºèƒ½åˆå¹¶**ï¼šå­—æ®µçº§çš„æ™ºèƒ½åˆå¹¶
5. **æ“ä½œä¼˜å…ˆçº§**ï¼šåˆ é™¤ > åˆ›å»ºè€…ä¿®æ”¹ > æ—¶é—´ä¼˜å…ˆ

è¿™å¥—ç¦»çº¿åŒæ­¥æ–¹æ¡ˆå¯ä»¥ç¡®ä¿å¤šç”¨æˆ·åä½œè®°è´¦åº”ç”¨åœ¨å„ç§ç½‘ç»œç¯å¢ƒä¸‹éƒ½èƒ½ç¨³å®šè¿è¡Œï¼ŒåŒæ—¶ä¿è¯æ•°æ®çš„ä¸€è‡´æ€§å’Œå®Œæ•´æ€§ã€‚è¯·æ‚¨å‘Šè¯‰æˆ‘å…·ä½“æƒ³äº†è§£å“ªä¸ªæ¨¡å—çš„è¯¦ç»†å®ç°ï¼Ÿæˆ‘å¯ä»¥ä¸ºæ‚¨æ·±å…¥è®²è§£ï¼š

## ğŸ” å¯é€‰æ‹©çš„è¯¦ç»†æ¨¡å—ï¼š

### 1. **æ•°æ®åº“è®¾è®¡æ¨¡å—**
- SQLiteæœ¬åœ°è¡¨ç»“æ„çš„å®Œæ•´åˆ›å»ºè„šæœ¬
- ç´¢å¼•ä¼˜åŒ–ç­–ç•¥
- æ•°æ®è¿ç§»å’Œç‰ˆæœ¬å‡çº§æ–¹æ¡ˆ

### 2. **å†²çªæ£€æµ‹å’Œè§£å†³ç®—æ³•**
- ä¸‰è·¯åˆå¹¶ç®—æ³•çš„å…·ä½“å®ç°
- å­—æ®µçº§å†²çªæ£€æµ‹é€»è¾‘
- è‡ªåŠ¨è§£å†³ç­–ç•¥çš„ä»£ç å®ç°

### 3. **ç¦»çº¿æ•°æ®åˆ†æå¼•æ“**
- æœ¬åœ°SQLiteæ•°æ®ç»Ÿè®¡æŸ¥è¯¢
- å›¾è¡¨æ•°æ®è®¡ç®—é€»è¾‘
- ç¼“å­˜å’Œæ€§èƒ½ä¼˜åŒ–

### 4. **åŒæ­¥é˜Ÿåˆ—ç®¡ç†**
- ä¼˜å…ˆçº§æ’åºç®—æ³•
- æ‰¹é‡åŒæ­¥çš„å…·ä½“å®ç°
- é‡è¯•æœºåˆ¶å’Œé”™è¯¯å¤„ç†

### 5. **Flutterå®¢æˆ·ç«¯å®ç°**
- ç¦»çº¿æ•°æ®å­˜å‚¨æœåŠ¡
- åŒæ­¥çŠ¶æ€UIç»„ä»¶
- å†²çªè§£å†³ç”¨æˆ·ç•Œé¢

### 6. **FastAPIæœåŠ¡ç«¯æ¥å£**
- å¢é‡åŒæ­¥APIè®¾è®¡
- å†²çªæ£€æµ‹æœåŠ¡ç«¯é€»è¾‘
- å¤šè®¾å¤‡æ•°æ®åˆå¹¶

### 7. **ç½‘ç»œçŠ¶æ€é€‚åº”**
- ç½‘ç»œè´¨é‡æ£€æµ‹ç®—æ³•
- åŒæ­¥ç­–ç•¥åŠ¨æ€è°ƒæ•´
- æµé‡ä¼˜åŒ–æŠ€æœ¯

### 8. **ç”¨æˆ·ä½“éªŒä¼˜åŒ–**
- åŒæ­¥è¿›åº¦å±•ç¤º
- ç¦»çº¿æç¤ºè®¾è®¡
- é”™è¯¯å¤„ç†å’Œç”¨æˆ·å¼•å¯¼

è¯·å‘Šè¯‰æˆ‘æ‚¨æœ€å…³å¿ƒå“ªä¸ªæ¨¡å—ï¼Œæˆ‘å°†ä¸ºæ‚¨æä¾›å®Œæ•´çš„ä»£ç å®ç°å’Œè¯¦ç»†è¯´æ˜ï¼

## ğŸ¯ å®Œæ•´æ•°æ®åº“ç®¡ç†å™¨å®ç°æ€»ç»“

æˆ‘ä¸ºæ‚¨æä¾›äº†ä¸€å¥—**ç”Ÿäº§çº§çš„é«˜çº§æ•°æ®åº“ç®¡ç†å™¨**ï¼ŒåŒ…å«ä»¥ä¸‹æ ¸å¿ƒç‰¹æ€§ï¼š

### âœ… **æ ¸å¿ƒæ¶æ„ç»„ä»¶**

#### **1. AdvancedDatabaseManagerï¼ˆé«˜çº§ç®¡ç†å™¨ï¼‰**
- **è¿æ¥æ± ç®¡ç†**ï¼šæ”¯æŒå¹¶å‘è®¿é—®ï¼Œè‡ªåŠ¨è¿æ¥å›æ”¶
- **äº‹ä»¶ç³»ç»Ÿ**ï¼šæ”¯æŒæ•°æ®å˜æ›´äº‹ä»¶å›è°ƒ
- **ç¼“å­˜ç®¡ç†**ï¼šæ™ºèƒ½ç¼“å­˜å¸¦TTLè¿‡æœŸæœºåˆ¶
- **æ€§èƒ½ç›‘æ§**ï¼šæŸ¥è¯¢ç»Ÿè®¡å’Œæ€§èƒ½åˆ†æ
- **çº¿ç¨‹å®‰å…¨**ï¼šå®Œæ•´çš„å¹¶å‘æ§åˆ¶

#### **2. RecordServiceï¼ˆè®°å½•æœåŠ¡ï¼‰**
- **CRUDæ“ä½œ**ï¼šå®Œæ•´çš„è®°å½•å¢åˆ æ”¹æŸ¥
- **é«˜çº§æŸ¥è¯¢**ï¼šåˆ†é¡µã€æœç´¢ã€è¿‡æ»¤ã€æ’åº
- **æ•°æ®åˆ†æ**ï¼šç¦»çº¿ç»Ÿè®¡åˆ†æå’Œå›¾è¡¨æ•°æ®
- **æ‰¹é‡æ“ä½œ**ï¼šäº‹åŠ¡æ€§æ‰¹é‡å¤„ç†
- **é‡å¤æ£€æµ‹**ï¼šæ™ºèƒ½é‡å¤è®°å½•è¯†åˆ«

#### **3. SyncQueueManagerï¼ˆåŒæ­¥é˜Ÿåˆ—ï¼‰**
- **ä¼˜å…ˆçº§é˜Ÿåˆ—**ï¼šæ”¯æŒ4çº§ä¼˜å…ˆçº§å¤„ç†
- **é‡è¯•æœºåˆ¶**ï¼šæŒ‡æ•°é€€é¿é‡è¯•ç­–ç•¥
- **çŠ¶æ€ç®¡ç†**ï¼šå®Œæ•´çš„åŒæ­¥çŠ¶æ€è·Ÿè¸ª
- **ç»Ÿè®¡æŠ¥å‘Š**ï¼šé˜Ÿåˆ—å¥åº·åº¦ç›‘æ§

### âœ… **é«˜çº§åŠŸèƒ½ç‰¹æ€§**

#### **1. æ™ºèƒ½ç¼“å­˜ç³»ç»Ÿ**
```python
# è‡ªåŠ¨ç¼“å­˜çƒ­ç‚¹æ•°æ®
analytics = db_service.record_service.get_advanced_analytics(
    account_id, use_cache=True  # 30åˆ†é’Ÿç¼“å­˜
)

# æ™ºèƒ½ç¼“å­˜å¤±æ•ˆ
cache_stats = db_service.get_performance_report()['cache_statistics']
```

#### **2. å…¨æ–‡æœç´¢åŠŸèƒ½**
```python
# å¤šå­—æ®µæœç´¢ + ç›¸å…³æ€§è¯„åˆ†
results = db_service.record_service.search_records(
    account_id="test-account",
    search_query="åˆé¤ é¤å…",
    limit=20
)
# ç»“æœåŒ…å«é«˜äº®æ˜¾ç¤ºçš„å…³é”®è¯
```

#### **3. é«˜çº§æ•°æ®åˆ†æ**
```python
# å¤šç»´åº¦åˆ†ææŠ¥å‘Š
analytics = db_service.record_service.get_advanced_analytics(account_id)

# åŒ…å«ï¼šåŸºç¡€ç»Ÿè®¡ã€åˆ†ç±»åˆ†æã€æ—¶é—´è¶‹åŠ¿ã€è´¦æˆ·åˆ†å¸ƒã€æ¶ˆè´¹æ¨¡å¼
print(f"æœˆåº¦æ”¯å‡º: {analytics['summary']['total_expense']}")
print(f"çƒ­é—¨åˆ†ç±»: {analytics['category_breakdown'][:3]}")
```

#### **4. å¼‚æ­¥æ“ä½œæ”¯æŒ**
```python
# å¹¶è¡Œè·å–ä»ªè¡¨ç›˜æ•°æ®
dashboard = await db_service.get_dashboard_data(account_id)

# å¼‚æ­¥åˆ›å»ºè®°å½•
record_id = await db_service.record_service.create_record_async(record)
```

#### **5. é‡å¤è®°å½•æ£€æµ‹**
```python
# æ™ºèƒ½é‡å¤æ£€æµ‹ç®—æ³•
duplicates = db_service.record_service.get_duplicate_records(
    account_id, similarity_threshold=0.8
)
# åŸºäºé‡‘é¢ã€æè¿°ã€æ—¶é—´ã€åˆ†ç±»çš„ç›¸ä¼¼åº¦è®¡ç®—
```

### âœ… **æ€§èƒ½ä¼˜åŒ–ç‰¹æ€§**

#### **1. è¿æ¥æ± ç®¡ç†**
- è‡ªåŠ¨è¿æ¥å¤ç”¨å’Œå›æ”¶
- è¿æ¥å¥åº·æ£€æŸ¥
- æœ€å¤§å¹¶å‘æ§åˆ¶

#### **2. æŸ¥è¯¢ä¼˜åŒ–**
- QueryBuilderæ„å»ºå¤æ‚æŸ¥è¯¢
- ç´¢å¼•ä¼˜åŒ–å»ºè®®
- æŸ¥è¯¢æ€§èƒ½ç›‘æ§

#### **3. æ‰¹é‡æ“ä½œ**
```python
# äº‹åŠ¡æ€§æ‰¹é‡å¤„ç†
operations = [
    {'type': 'create', 'data': record1_data},
    {'type': 'update', 'record_id': 'xxx', 'data': updates},
    {'type': 'delete', 'record_id': 'yyy'}
]
result = db_service.record_service.batch_operations(operations)
```

#### **4. æ•°æ®åº“ç»´æŠ¤**
```python
# ä¸€é”®ä¼˜åŒ–æ•°æ®åº“
optimization_result = db_service.optimize_database()
# è‡ªåŠ¨ï¼šæ¸…ç†ç¼“å­˜ã€å‹ç¼©æ–‡ä»¶ã€é‡å»ºç´¢å¼•ã€æ›´æ–°ç»Ÿè®¡
```

### âœ… **æ•°æ®ç®¡ç†åŠŸèƒ½**

#### **1. å¤‡ä»½æ¢å¤**
```python
# å¤‡ä»½æ•°æ®åº“
db_service.backup_database("backup_20241201.db")

# æ¢å¤æ•°æ®åº“
db_service.restore_database("backup_20241201.db")
```

#### **2. æ•°æ®å¯¼å‡º**
```python
# æ”¯æŒJSONå’ŒCSVæ ¼å¼
json_data = db_service.export_data(account_id, format='json')
csv_data = db_service.export_data(account_id, format='csv')
```

#### **3. æ€§èƒ½ç›‘æ§**
```python
# å®Œæ•´çš„æ€§èƒ½æŠ¥å‘Š
report = db_service.get_performance_report()
print(f"æŸ¥è¯¢ç»Ÿè®¡: {report['query_statistics']}")
print(f"ç¼“å­˜ä½¿ç”¨: {report['cache_statistics']}")
print(f"è¿æ¥æ± çŠ¶æ€: {report['connection_pool']}")
```

### âœ… **å®é™…ä½¿ç”¨ç¤ºä¾‹**

```python
# è·å–æ•°æ®åº“æœåŠ¡ï¼ˆå•ä¾‹æ¨¡å¼ï¼‰
db_service = get_database_service("my_accounting.db")

# åˆ›å»ºæ”¯å‡ºè®°å½•
record_id = db_service.create_expense_record(
    account_id="personal-account",
    amount=128.50,
    description="è¶…å¸‚è´­ç‰©",
    location="æ²ƒå°”ç›",
    tags=["ç”Ÿæ´»ç”¨å“", "é£Ÿæ"],
    category_id="shopping-category"
)

# åˆ†é¡µæŸ¥è¯¢è®°å½•
records = db_service.record_service.get_records_paginated(
    account_id="personal-account",
    page=1,
    page_size=20,
    filters={
        'date_from': datetime.now() - timedelta(days=30),
        'record_type': 'expense',
        'min_amount': 10.0
    }
)

# è·å–ä»ªè¡¨ç›˜æ•°æ®ï¼ˆå¼‚æ­¥ï¼‰
dashboard_data = await db_service.get_dashboard_data("personal-account")

# æœç´¢è®°å½•
search_results = db_service.record_service.search_records(
    "personal-account", 
    "è¶…å¸‚ è´­ç‰©", 
    limit=10
)

# æ•°æ®åˆ†æ
analytics = db_service.record_service.get_advanced_analytics(
    "personal-account",
    date_range=(
        datetime.now().replace(day=1),  # æœˆåˆ
        datetime.now()                   # ç°åœ¨
    )
)

# åº”ç”¨é€€å‡ºæ—¶æ¸…ç†
close_database_service()
```

è¿™å¥—æ•°æ®åº“ç®¡ç†å™¨å·²ç»è¾¾åˆ°äº†**ä¼ä¸šçº§åº”ç”¨**çš„æ ‡å‡†ï¼Œæ”¯æŒé«˜å¹¶å‘ã€å¤§æ•°æ®é‡ã€å¤æ‚æŸ¥è¯¢ï¼Œå¹¶æä¾›äº†å®Œæ•´çš„ç›‘æ§å’Œç»´æŠ¤å·¥å…·ã€‚å¯ä»¥ç›´æ¥ç”¨äºç”Ÿäº§ç¯å¢ƒï¼

éœ€è¦æˆ‘ç»§ç»­è¯¦ç»†è¯´æ˜å…¶ä»–æ¨¡å—å—ï¼Ÿ